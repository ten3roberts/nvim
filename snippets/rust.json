{
  "tracing-info": {
    "prefix": "info",
    "body": [
      "tracing::info!(${1});"
    ]
  },
  "profile-function": {
    "prefix": "profile_function",
    "body": [
      "profile_function!();"
    ]
  },
  "profile-scope": {
    "prefix": "profile_scope",
    "body": [
      "profile_scope!(\"{$1}\");{$2}"
    ]
  },
  "flume": {
    "prefix": "flume",
    "body": [ "let ($1tx, $1rx) = flume::unbounded();" ]
  },
  "if-ok": {
    "prefix": "if-ok",
    "body": [
      "if let Ok($1) = $2 {",
      "    $3",
      "}"
    ]
  },
  "if-some": {
    "prefix": "if-some",
    "body": [
      "if let Some($1) = $2 {",
      "    $3",
      "}"
    ]
  },
  "derive": {
    "prefix": "derive",
    "body": [
      "#[derive($1)]"
    ]
  },
  "serde-derive": {
    "prefix": "serde-derive",
    "body": [
      "#[derive(serde::Serialize, serde::Deserialize)]"
    ]
  },
  "serde-attr": {
    "prefix": "serde-attr",
    "body": [
      "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))"
    ]
  },
  "default": {
    "prefix": "default",
    "body": [
      "Default::default()"
    ]
  },
  "fnew": {
    "prefix": "fnew",
    "body": [
      "fn new($1) -> Self {",
      "    Self { $2 }",
      "}"
    ]
  },
  "result-match": {
    "prefix": "match-result",
    "body": [
      "match $1 {",
      "    Ok($2) => $3,",
      "    Err($4) => $5,",
      "}"
    ]
  },
  "result-unwrap-or": {
    "prefix": "unwrap-or",
    "body": ["$1.unwrap_or($2)"]
  },
  "result-unwrap-or-else": {
    "prefix": "unwrap-or-else",
    "body": ["$1.unwrap_or_else(|$2| $3)"]
  },
  "iter-map-collect": {
    "prefix": "map-collect",
    "body": ["$1.iter().map(|$2| $3).collect::<Vec<_>>()"]
  },
  "iter-filter-map": {
    "prefix": "filter-map",
    "body": ["$1.iter().filter_map(|$2| $3).collect::<Vec<_>>()"]
  },
  "iter-fold": {
    "prefix": "fold",
    "body": ["$1.iter().fold($2, |acc, $3| $4)"]
  },
  "async-fn": {
    "prefix": "async-fn",
    "body": [
      "async fn $1($2) -> $3 {",
      "    $4",
      "}"
    ]
  },
  "tokio-spawn": {
    "prefix": "spawn",
    "body": ["tokio::spawn(async move { $1 });"]
  },
  "join-handle": {
    "prefix": "join",
    "body": ["$1.await.expect(\"$2\")"]
  },
  "test-fn": {
    "prefix": "test",
    "body": [
      "#[test]",
      "fn test_$1() {",
      "    $2",
      "}"
    ]
  },
  "assert-eq": {
    "prefix": "assert-eq",
    "body": ["assert_eq!($1, $2);"]
  },
  "assert": {
    "prefix": "assert",
    "body": ["assert!($1);"]
  },
  "println": {
    "prefix": "println",
    "body": ["println!(\"$1\");"]
  },
  "format": {
    "prefix": "format",
    "body": ["format!(\"$1\")"]
  },
  "vec-new": {
    "prefix": "vec",
    "body": ["vec![$1]"]
  },
  "hashmap-new": {
    "prefix": "hashmap",
    "body": ["std::collections::HashMap::new()"]
  },
  "impl-block": {
    "prefix": "impl",
    "body": [
      "impl $1 {",
      "    $2",
      "}"
    ]
  },
  "impl-trait": {
    "prefix": "impl-trait",
    "body": [
      "impl $1 for $2 {",
      "    $3",
      "}"
    ]
  },
  "match-exhaustive": {
    "prefix": "match",
    "body": [
      "match $1 {",
      "    $2 => $3,",
      "    _ => $4,",
      "}"
    ]
  },
  "match-option": {
    "prefix": "match-option",
    "body": [
      "match $1 {",
      "    Some($2) => $3,",
      "    None => $4,",
      "}"
    ]
  },
  "static-lifetime": {
    "prefix": "static",
    "body": ["&'static $1"]
  },
  "modtests": {
    "prefix": "modtests",
    "body": [
      "#[cfg(test)]",
      "mod tests {",
      "    ${1:use super::*;}",
      "",
      "    ${2}",
      "}"
    ],
    "description": "Test module"
  },
  "pubuse": {
    "prefix": "pubuse",
    "body": "pub use ${1}::*;",
    "description": "Public use"
  },
  "test": {
    "prefix": "test",
    "body": [
      "#[test]",
      "fn ${1}() {",
      "    ${2}",
      "}${0}"
    ],
    "description": "Test function"
  },
  "cowstr": {
    "prefix": "cowstr",
    "body": "Cow<'${1:static}, ${2:str}>",
    "description": "Cow string"
  },
  "icowstr": {
    "prefix": "icowstr",
    "body": "Into<Cow<'${1:static}, ${2:str}>>",
    "description": "Into Cow string"
  },
  "map_into": {
    "prefix": "map_into",
    "body": "${1:map(Into::into)}",
    "description": "Map into"
  },
  "map_err": {
    "prefix": "map_err",
    "body": "${1:map_err(Into::into)}",
    "description": "Map err"
  },
  "struct-pod": {
    "prefix": "struct-pod",
    "body": [
      "#[repr(C)]",
      "#[derive(bytemuck::Pod, bytemuck::Zeroable, Clone, Copy, Debug)]",
      "pub struct ${1:name} {",
      "    ${2}",
      "}"
    ],
    "description": "POD struct"
  },
  "fn": {
    "prefix": "fn",
    "body": [
      "fn ${1:name}(${2}) ${3:-> _} {",
      "    ${4:todo!()}",
      "}"
    ],
    "description": "Function"
  },
  "pf": {
    "prefix": "pf",
    "body": [
      "pub fn ${1:name}(${2}) ${3:-> _} {",
      "    ${4:todo!()}",
      "}"
    ],
    "description": "Public function"
  },
  "struct": {
    "prefix": "struct",
    "body": [
      "#[derive(${1:Debug, Clone})]",
      "struct ${2:Name} {",
      "    ${3}",
      "}"
    ],
    "description": "Struct"
  },
  "enum": {
    "prefix": "enum",
    "body": [
      "#[derive(${1:Debug, Clone})]",
      "enum ${2:Name} {",
      "    ${3}",
      "}"
    ],
    "description": "Enum"
  },
  "impl": {
    "prefix": "impl",
    "body": [
      "impl${1:<T>} ${2:Type} {",
      "    ${3}",
      "}"
    ],
    "description": "Impl block"
  },
  "buf": {
    "prefix": "buf",
    "body": "let mut buf = ${1:Vec}::new();",
    "description": "Buffer"
  },
  "with": {
    "prefix": "with",
    "body": [
      "pub fn with_${1}(${2:self}, ${3:value}: ${4:Type}) -> ${5:Self} {",
      "    self.${1} = ${3};",
      "    self",
      "}"
    ],
    "description": "With builder"
  },
  "de_serde": {
    "prefix": "de_serde",
    "body": "#[derive(serde::Serialize, serde::Deserialize)]",
    "description": "Serde derive"
  },
  "attr_serde": {
    "prefix": "attr_serde",
    "body": "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]",
    "description": "Serde attr"
  },
  "trace": {
    "prefix": "trace",
    "body": "${1:tracing}::trace!(${2}\"${3}\");",
    "description": "Trace log"
  },
  "debug": {
    "prefix": "debug",
    "body": "${1:tracing}::debug!(${2}\"${3}\");",
    "description": "Debug log"
  },
  "warn": {
    "prefix": "warn",
    "body": "${1:tracing}::warn!(${2}\"${3}\");",
    "description": "Warn log"
  },
  "error": {
    "prefix": "error",
    "body": "${1:tracing}::error!(${2}\"${3}\");",
    "description": "Error log"
  },
  "instrument": {
    "prefix": "instrument",
    "body": "#[tracing::instrument(level = \"info\")]",
    "description": "Instrument"
  },
  "instrument_trace": {
    "prefix": "instrument_trace",
    "body": "#[tracing::instrument(level = \"trace\")]",
    "description": "Instrument trace"
  },
  "instrument_debug": {
    "prefix": "instrument_debug",
    "body": "#[tracing::instrument(level = \"debug\")]",
    "description": "Instrument debug"
  },
  "instrument_info": {
    "prefix": "instrument_info",
    "body": "#[tracing::instrument(level = \"info\")]",
    "description": "Instrument info"
  },
  "instrument_warn": {
    "prefix": "instrument_warn",
    "body": "#[tracing::instrument(level = \"warn\")]",
    "description": "Instrument warn"
  },
  "instrument_error": {
    "prefix": "instrument_error",
    "body": "#[tracing::instrument(level = \"error\")]",
    "description": "Instrument error"
  },
  "info_span": {
    "prefix": "info_span",
    "body": "let _span = tracing::info_span!(${1}).entered();",
    "description": "Info span"
  },
  "debug_span": {
    "prefix": "debug_span",
    "body": "let _span = tracing::debug_span!(${1}).entered();",
    "description": "Debug span"
  },
  "doc_hidden": {
    "prefix": "doc_hidden",
    "body": "#[doc(hidden)]",
    "description": "Doc hidden"
  },
  "cfg_unknown": {
    "prefix": "cfg_unknown",
    "body": "#[cfg(target_os = \"unknown\")]",
    "description": "Cfg unknown"
  },
  "cfg_not_unknown": {
    "prefix": "cfg_not_unknown",
    "body": "#[cfg(not(target_os = \"unknown\"))]",
    "description": "Cfg not unknown"
  },
  "cfg_arch": {
    "prefix": "cfg_arch",
    "body": "#[cfg(target_arch = \"${1}\")]",
    "description": "Cfg arch"
  },
  "cfg_not_arch": {
    "prefix": "cfg_not_arch",
    "body": "#[cfg(not(target_arch = \"${1}\"))]",
    "description": "Cfg not arch"
  },
  "cfg_wasm32": {
    "prefix": "cfg_wasm32",
    "body": "#[cfg(target_arch = \"wasm32\")]",
    "description": "Cfg wasm32"
  },
  "cfg_not_wasm32": {
    "prefix": "cfg_not_wasm32",
    "body": "#[cfg(not(target_arch = \"wasm32\"))]",
    "description": "Cfg not wasm32"
  },
  "cfgf": {
    "prefix": "cfgf",
    "body": "#[cfg(feature = \"${1}\")]",
    "description": "Cfg feature"
  },
  "ANCHOR": {
    "prefix": "ANCHOR",
    "body": [
      "// ANCHOR: ${1}",
      "${2}",
      "// ANCHOR_END: ${1}"
    ],
    "description": "Anchor"
  },
  "split_for_impl": {
    "prefix": "split_for_impl",
    "body": "let (impl_generics, ty_generics, where_clause) = ${1:generics}.split_for_impl();",
    "description": "Split for impl"
  },
  "de_serde_attr": {
    "prefix": "de_serde_attr",
    "body": "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]",
    "description": "Serde attr"
  }
}
